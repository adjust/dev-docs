---
title: "다이렉트 딥링크 설정"
description: "앱의 다이렉트 딥링킹을 구성합니다."
slug: "en/sdk/ios/features/deep-links/direct"
sidebar-position: 3
multiVersion: true
---
<sdkversion version="v5"> 

Adjust 대시보드에서 딥링크가 설정되면 앱에서 딥링크를 구성할 수 있습니다.  **다이렉트 딥링크** 는 사용자가 이미 기기에 앱을 설치한 경우에 작동하며, 사용자를 앱 내 특정 페이지로 이동시킵니다.

딥링크를 활성화하려면 다음을 수행해야 합니다.

* [ ]  앱의 Associated Domains 활성화
* [ ]  Xcode에서 딥링크 구성

[Associated Domains 활성화](enable-associated-domains)
---------------------------------------------------

Apple 개발자 계정에서 Associated Domains를 활성화해야, 앱에서 유니버설 링크 도메인을 설정할 수 있습니다. 이를 위해 다음의 단계를 수행하시기 바랍니다.

1. [Apple 개발자 계정](https://developer.apple.com/account/)에 로그인합니다.
2. 왼쪽 메뉴에서 **Certificates, IDs & Profiles** 를 선택합니다.
3. 왼쪽 메뉴에서 **Identifiers** 를 선택합니다.
4. 앱을 찾은 뒤 선택하여 편집 페이지를 실행합니다.
5. **Associated Domains** 가 **Capabilities** 아래에 체크 표시되어있는지 확인합니다.
6. **Save** 를 선택하여 변경 내용을 저장합니다.

[Xcode에서 딥링크 구성](configure-deep-links-in-xcode)
-----------------------------------------------

다음의 단계를 수행하여 Xcode 프로젝트에 딥링크 구성을 추가하시기 바랍니다.

### [Adjust 유니버설 링크 도메인](adjust-universal-links-domain)

1. Xcode에서 앱 프로젝트를 실행합니다.
2. 왼쪽 메뉴에서 프로젝트를 선택합니다.
3. **Targets** 에서 앱을 선택합니다.
4. 상단 메뉴에서 **Signing & Capabilities** 를 선택합니다.
5. 아래 하위 메뉴에 **All** 이 선택되어 있는지 확인합니다.
6. Add 옵션\( **\+** \)을 선택하여 기능을 추가합니다.
7. **Associated Domains** 를 선택합니다.
8. 접두어와 함께 Adjust 유니버설 링크 도메인을 입력합니다. `applinks:` 
   * 다음은 `example.adj.st` 도메인을 사용한 예시입니다. `applinks:example.adj.st`

### [커스텀 URL 스킴](custom-url-scheme)

<callout type="tip"> 

마케팅팀과 확인하여 앱에 맞춤 URL 스킴이 필요한지 확인하고, 스킴 이름을 논의하시기 바랍니다. 앱이 Android 기기도 타겟팅하는 경우, 각 플랫폼에 동일한 스킴 이름을 사용하시기 바랍니다.
</Callout> 

1. Xcode에서 앱 프로젝트를 실행합니다.
2. 왼쪽 메뉴에서 프로젝트를 선택합니다.
3. **Targets** 에서 앱을 선택합니다.
4. 상단 메뉴에서 **Info** 를 선택합니다.
5. **URL Types** 섹션을 펼쳐보기 합니다.
6. Add 옵션\( **\+** \)을 선택하여 URL 유형을 추가합니다.
7. 다음의 정보를 입력하여 URL 스킴을 생성합니다. 
   * **식별자** : `$(PRODUCT_BUNDLE_IDENTIFIER)`
   * **URL 스킴** : 맞춤 URL 스킴. 반드시 고유해야 합니다. 다음과 같은 보안 스킴을 사용하지 마시기 바랍니다. `http`, `https` 또는 `mailto`
   * **역할** : 편집자

이 스킴은 프로덕션과 디버그 빌드 **모두** 에 작동합니다.

[iOS 앱 변경](modify-your-ios-app)
-------------------------------

다양한 딥링크 시나리오를 설정하려면 iOS 앱을 업데이트해야 합니다. 앱을 업데이트 하는 방식은 앱이 [scene](https://developer.apple.com/documentation/uikit/app_and_environment/scenes)을 사용하는지 여부에 따라 달라집니다.

### [앱이 scene을 사용하지 않는 경우](app-doesn-t-use-scenes)

앱이 scene을 사용하지 않는 경우, 앱 델리게이트에서 메서드를 업데이트해야 합니다.

#### [유니버설 링크](universal-links)

Adjust SDK에서 다음의 메서드를 호출하기 위해 앱 델리게이트에서 `application(_:continue:restorationHandler:)` 메서드를 업데이트합니다.

* `ADJLinkResolution.resolveLink`: 마케팅팀이 Adjust의 링크 해석\(link resolution\) 솔루션이 필요한 경우에만 이 메서드를 호출합니다. 딥링크가 `resolveUrlSuffixArray`의 요소와 일치하는 도메인을 사용하는 경우, 이 메서드는 딥링크를 해석하려고 시도하여 해석된 링크를 반환합니다. 딥링크가 이 배열의 요소와 일치하지 않는 경우, 이 메서드는 원래의 딥링크를 전달하므로 모든 딥링크를 이 메서드로 전달할 수 있습니다.
* `Adjust.processDeeplink` \- 이 메서드를 호출하여 정보 기록을 위해 딥링크를 Adjust 서버로 전송합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.

사용자가 유니버설 링크를 클릭하면 iOS가 앱을 실행하고 딥링크를 `application(_:continue:restorationHandler:)`으로 전달합니다. 이는 사용자가 앱을 종료한 상태거나 앱이 백그라운드에서 실행 중인지와 관계없이 작동합니다.
<tabs> <tab title="Swift" sync="swift"> 

```swift
func application(
    _ application: UIApplication,
    continue userActivity: NSUserActivity,
    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void)
    -> Bool {

    if userActivity.activityType == NSUserActivityTypeBrowsingWeb {
        let incomingURL = userActivity.webpageURL

        // call the below method to resolve deep link
        ADJLinkResolution.resolveLink(
        withUrl: incomingURL,
        resolveUrlSuffixArray: ["email.example.com", "short.example.com"],
        callback: { resolvedURL in
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            Adjust.processDeeplink(resolvedURL)
        })
      } else {
          return false
      }

      return true
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (BOOL)application:(UIApplication *)application
    continueUserActivity:(NSUserActivity *)userActivity
    restorationHandler:
    (void (^)(NSArray *restorableObjects))restorationHandler {

    if ([[userActivity activityType]
        isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *incomingURL = [userActivity webpageURL];

        // call the below method to resolve deep link
        [ADJLinkResolution
        resolveLinkWithUrl:incomingURL
        resolveUrlSuffixArray:@[
        @"email.example.com", @"short.example.com"
        ]
        callback:^(NSURL* _Nullable resolvedURL) {
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            [Adjust processDeeplink:resolvedURL];
        }];
    } else {
        return NO;
    }

    return YES;
}
```

</Tab> </Tabs> 

#### [커스텀 URL 스킴](custom-url-scheme-1)

마케팅팀이 맞춤 URL 스킴 딥링크 설정을 원하는 경우, 앱 델리게이트에서 `application(_:open:options:)` 메서드를 업데이트하고 Adjust SDK에서 `Adjust.processDeeplink` 메서드를 호출합니다. 이 메서드는 딥링크를 Adjust 서버로 전송하여 이를 기록합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.

사용자가 맞춤 URL 스킴 딥링크를 클릭하면 iOS가 앱을 실행하고 딥링크를 `application(_:open:options:)`으로 전달합니다. 이는 사용자가 앱을 종료한 상태거나 앱이 백그라운드에서 실행 중인지와 관계없이 작동합니다.
<tabs> <tab title="Swift" sync="swift"> 

```swift
func application(
    _ app: UIApplication,
    open incomingURL: URL,
    options: [UIApplication.OpenURLOptionsKey: Any] = [:]
    ) -> Bool {

    // add your code below to handle deep link
    // (for example, open deep link content)
    // incomingURL object contains the deep link


    // call the below method to send deep link to Adjust's servers
    Adjust.processDeeplink(incomingURL)

    return true
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (BOOL)application:(UIApplication *)app
    openURL:(NSURL *)incomingURL
    options:(NSDictionary *)options {

    // add your code below to handle deep link
    // (for example, open deep link content)
    // incomingURL object contains the deep link


    // call the below method to send deep link to Adjust's servers
    [Adjust processDeeplink:incomingURL];

    return YES;
}
```

</Tab> </Tabs> 

### [앱이 scene을 사용하는 경우](app-uses-scenes)

앱이 scene을 사용하는 경우, scene 델리게이트에서 메서드를 업데이트해야 합니다.

#### [유니버설 링크](universal-links-1)

1. scene 델리게이트에서 `scene(_:willConnectTo:options:)` 메서드를 업데이트합니다. 사용자가 유니버설 링크를 클릭하고 앱은 종료된 상태인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.
2. scene 델리게이트에서 `scene(_:continue:)` 메서드를 업데이트합니다. 사용자가 유니버설 링크를 클릭하고 앱이 백그라운드에서 실행 중인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.

위 메서드는 Adjust SDK에서 다음의 메서드를 호출합니다.

* `ADJLinkResolution.resolveLink`: 마케팅팀이 Adjust의 링크 해석\(link resolution\) 솔루션이 필요한 경우에만 이 메서드를 호출합니다. 딥링크가 `resolveUrlSuffixArray`의 요소와 일치하는 도메인을 사용하는 경우, 이 메서드는 딥링크를 해석하려고 시도하여 해석된 링크를 반환합니다. 딥링크가 이 배열의 요소와 일치하지 않는 경우, 이 메서드는 원래의 딥링크를 전달하므로 모든 딥링크를 이 메서드로 전달할 수 있습니다.
* `Adjust.processDeeplink` \- 이 메서드를 호출하여 기록을 위해 딥링크를 Adjust 서버로 전송합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.

<tabs> <tab title="Swift" sync="swift"> 

```swift
func scene(
    _ scene: UIScene,
    willConnectTo session: UISceneSession,
    options connectionOptions: UIScene.ConnectionOptions
    ) {

    guard let userActivity = connectionOptions.userActivities.first,
      userActivity.activityType == NSUserActivityTypeBrowsingWeb,
      let incomingURL = userActivity.webpageURL
    else { return }

    // call the below method to resolve deep link
    ADJLinkResolution.resolveLink(
      withUrl: incomingURL,
      resolveUrlSuffixArray: ["email.example.com", "short.example.com"],
      callback: { resolvedURL in
        // add your code below to handle deep link
        // (for example, open deep link content)
        // resolvedURL object contains the deep link


        // call the below method to send deep link to Adjust's servers
        Adjust.processDeeplink(resolvedURL)
      })
}

func scene(
    _ scene: UIScene,
    continue userActivity: NSUserActivity) {

    if userActivity.activityType == NSUserActivityTypeBrowsingWeb {
        let incomingURL = userActivity.webpageURL

        // call the below method to resolve deep link
        ADJLinkResolution.resolveLink(
        withUrl: incomingURL,
        resolveUrlSuffixArray: ["email.example.com", "short.example.com"],
        callback: { resolvedURL in
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            Adjust.processDeeplink(resolvedURL)
        })
    }
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session
    options:(UISceneConnectionOptions *)connectionOptions {

    NSUserActivity* userActivity =
    [[[connectionOptions userActivities] allObjects] firstObject];

    if ([[userActivity activityType]
        isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *incomingURL = [userActivity webpageURL];

        // call the below method to resolve deep link
        [ADJLinkResolution
        resolveLinkWithUrl:incomingURL
        resolveUrlSuffixArray:@[
        @"email.example.com", @"short.example.com"
        ]
        callback:^(NSURL* _Nullable resolvedURL) {
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            [Adjust processDeeplink:resolvedURL];
        }];
    }
}

- (void)scene:(UIScene *)scene continueUserActivity:(NSUserActivity *)userActivity{
    if ([[userActivity activityType]
        isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *incomingURL = [userActivity webpageURL];

        // call the below method to resolve deep link
        [ADJLinkResolution
        resolveLinkWithUrl:incomingURL
        resolveUrlSuffixArray:@[
        @"email.example.com", @"short.example.com"
        ]
        callback:^(NSURL* _Nullable resolvedURL) {
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            [Adjust processDeeplink:resolvedURL];
        }];
    }
}
```

</Tab> </Tabs> 

#### [커스텀 URL 스킴](custom-url-scheme-2)

1. scene 델리게이트에서 `scene(_:willConnectTo:options:)` 메서드를 업데이트합니다. 사용자가 맞춤 URL 스킴 딥링크를 클릭하고 앱은 종료된 상태인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.
2. scene 델리게이트에서 `scene(_:openURLContexts:)` 메서드를 업데이트합니다. 사용자가 맞춤 URL 스킴 딥링크를 클릭하고 앱이 백그라운드에서 실행 중인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.

위 메서드는 Adjust SDK에서 `Adjust.appWillOpen` 메서드를 호출합니다. 이 메서드는 딥링크를 Adjust 서버로 전송하여 이를 기록합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.
<tabs> <tab title="Swift" sync="swift"> 

```swift
func scene(
    _ scene: UIScene,
    openURLContexts URLContexts: Set<uiopenurlcontext id="sl-md0000000">
    ) {

    guard let incomingURL = URLContexts.first?.url else {
        return
    }

    // add your code below to handle deep link
    // (for example, open deep link content)
    // incomingURL object contains the deep link


    // call the below method to send deep link to Adjust's servers
    Adjust.processDeeplink(incomingURL)
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (void)scene:(UIScene *)scene
    openURLContexts:(nonnull NSSet<uiopenurlcontext * id="sl-md0000000"> *)URLContexts {

    NSURL *incomingURL = [[URLContexts allObjects] firstObject].URL;

    if (incomingURL) {
        // add your code below to handle deep link
        // (for example, open deep link content)
        // incomingURL object contains the deep link


        // call the below method to send deep link to Adjust's servers
        [Adjust processDeeplink:incomingURL];
    }
}
```

</Tab> </Tabs> </SdkVersion> <sdkversion version="v4"> 

Adjust 대시보드에서 딥링크가 설정되면 앱에서 딥링크를 구성할 수 있습니다.  **다이렉트 딥링크** 는 사용자가 이미 기기에 앱을 설치한 경우에 작동하며, 사용자를 앱 내 특정 페이지로 이동시킵니다.

딥링크를 활성화하려면 다음을 수행해야 합니다.

* [ ]  앱의 Associated Domains 활성화
* [ ]  Xcode에서 딥링크 구성

[Associated Domains 활성화](enable-associated-domains)
---------------------------------------------------

Apple 개발자 계정에서 Associated Domains를 활성화해야, 앱에서 유니버설 링크 도메인을 설정할 수 있습니다. 이를 위해 다음의 단계를 수행하시기 바랍니다.

1. [Apple 개발자 계정](https://developer.apple.com/account/)에 로그인합니다.
2. 왼쪽 메뉴에서 **Certificates, IDs & Profiles** 를 선택합니다.
3. 왼쪽 메뉴에서 **Identifiers** 를 선택합니다.
4. 앱을 찾은 뒤 선택하여 편집 페이지를 실행합니다.
5. **Associated Domains** 가 **Capabilities** 아래에 체크 표시되어있는지 확인합니다.
6. **Save** 를 선택하여 변경 내용을 저장합니다.

[Xcode에서 딥링크 구성](configure-deep-links-in-xcode)
-----------------------------------------------

다음의 단계를 수행하여 Xcode 프로젝트에 딥링크 구성을 추가하시기 바랍니다.

### [Adjust 유니버설 링크 도메인](adjust-universal-links-domain)

1. Xcode에서 앱 프로젝트를 실행합니다.
2. 왼쪽 메뉴에서 프로젝트를 선택합니다.
3. **Targets** 에서 앱을 선택합니다.
4. 상단 메뉴에서 **Signing & Capabilities** 를 선택합니다.
5. 아래 하위 메뉴에 **All** 이 선택되어 있는지 확인합니다.
6. Add 옵션\( **\+** \)을 선택하여 기능을 추가합니다.
7. **Associated Domains** 를 선택합니다.
8. 접두어와 함께 Adjust 유니버설 링크 도메인을 입력합니다. `applinks:` 
   * 다음은 `example.adj.st` 도메인을 사용한 예시입니다. `applinks:example.adj.st`

### [커스텀 URL 스킴](custom-url-scheme)

<callout type="tip"> 

마케팅팀과 확인하여 앱에 맞춤 URL 스킴이 필요한지 확인하고, 스킴 이름을 논의하시기 바랍니다. 앱이 Android 기기도 타겟팅하는 경우, 각 플랫폼에 동일한 스킴 이름을 사용하시기 바랍니다.
</Callout> 

1. Xcode에서 앱 프로젝트를 실행합니다.
2. 왼쪽 메뉴에서 프로젝트를 선택합니다.
3. **Targets** 에서 앱을 선택합니다.
4. 상단 메뉴에서 **Info** 를 선택합니다.
5. **URL Types** 섹션을 펼쳐보기 합니다.
6. Add 옵션\( **\+** \)을 선택하여 URL 유형을 추가합니다.
7. 다음의 정보를 입력하여 URL 스킴을 생성합니다. 
   * **식별자** : `$(PRODUCT_BUNDLE_IDENTIFIER)`
   * **URL 스킴** : 맞춤 URL 스킴. 반드시 고유해야 합니다. 다음과 같은 보안 스킴을 사용하지 마시기 바랍니다. `http`, `https` 또는 `mailto`
   * **역할** : 편집자

이 스킴은 프로덕션과 디버그 빌드 **모두** 에 작동합니다.

[iOS 앱 변경](modify-your-ios-app)
-------------------------------

다양한 딥링크 시나리오를 설정하려면 iOS 앱을 업데이트해야 합니다. 앱을 업데이트 하는 방식은 앱이 [scene](https://developer.apple.com/documentation/uikit/app_and_environment/scenes)을 사용하는지 여부에 따라 달라집니다.

### [앱이 scene을 사용하지 않는 경우](app-doesn-t-use-scenes)

앱이 scene을 사용하지 않는 경우, 앱 델리게이트에서 메서드를 업데이트해야 합니다.

#### [유니버설 링크](universal-links)

Adjust SDK에서 다음의 메서드를 호출하기 위해 앱 델리게이트에서 `application(_:continue:restorationHandler:)` 메서드를 업데이트합니다.

* `ADJLinkResolution.resolveLink`: 마케팅팀이 Adjust의 링크 해석\(link resolution\) 솔루션이 필요한 경우에만 이 메서드를 호출합니다. 딥링크가 `resolveUrlSuffixArray`의 요소와 일치하는 도메인을 사용하는 경우, 이 메서드는 딥링크를 해석하려고 시도하여 해석된 링크를 반환합니다. 딥링크가 이 배열의 요소와 일치하지 않는 경우, 이 메서드는 원래의 딥링크를 전달하므로 모든 딥링크를 이 메서드로 전달할 수 있습니다.
* `Adjust.appWillOpen` \- 이 메서드를 호출하여 정보 기록을 위해 딥링크를 Adjust 서버로 전송합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.

사용자가 유니버설 링크를 클릭하면 iOS가 앱을 실행하고 딥링크를 `application(_:continue:restorationHandler:)`으로 전달합니다. 이는 사용자가 앱을 종료한 상태거나 앱이 백그라운드에서 실행 중인지와 관계없이 작동합니다.
<tabs> <tab title="Swift" sync="swift"> 

```swift
func application(
    _ application: UIApplication,
    continue userActivity: NSUserActivity,
    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void)
    -> Bool {

    if userActivity.activityType == NSUserActivityTypeBrowsingWeb {
        let incomingURL = userActivity.webpageURL

        // call the below method to resolve deep link
        ADJLinkResolution.resolveLink(
        withUrl: incomingURL,
        resolveUrlSuffixArray: ["email.example.com", "short.example.com"],
        callback: { resolvedURL in
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            Adjust.appWillOpen(resolvedURL)
        })
      } else {
          return false
      }

      return true
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (BOOL)application:(UIApplication *)application
    continueUserActivity:(NSUserActivity *)userActivity
    restorationHandler:
    (void (^)(NSArray *restorableObjects))restorationHandler {

    if ([[userActivity activityType]
        isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *incomingURL = [userActivity webpageURL];

        // call the below method to resolve deep link
        [ADJLinkResolution
        resolveLinkWithUrl:incomingURL
        resolveUrlSuffixArray:@[
        @"email.example.com", @"short.example.com"
        ]
        callback:^(NSURL* _Nullable resolvedURL) {
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            [Adjust appWillOpenUrl:resolvedURL];
        }];
    } else {
        return NO;
    }

    return YES;
}
```

</Tab> </Tabs> 

#### [커스텀 URL 스킴](custom-url-scheme-1)

마케팅팀이 맞춤 URL 스킴 딥링크 설정을 원하는 경우, 앱 델리게이트에서 `application(_:open:options:)` 메서드를 업데이트하고 Adjust SDK에서 `Adjust.appWillOpen` 메서드를 호출합니다. 이 메서드는 딥링크를 Adjust 서버로 전송하여 이를 기록합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.

사용자가 맞춤 URL 스킴 딥링크를 클릭하면 iOS가 앱을 실행하고 딥링크를 `application(_:open:options:)`으로 전달합니다. 이는 사용자가 앱을 종료한 상태거나 앱이 백그라운드에서 실행 중인지와 관계없이 작동합니다.
<tabs> <tab title="Swift" sync="swift"> 

```swift
func application(
    _ app: UIApplication,
    open incomingURL: URL,
    options: [UIApplication.OpenURLOptionsKey: Any] = [:]
    ) -> Bool {

    // add your code below to handle deep link
    // (for example, open deep link content)
    // incomingURL object contains the deep link


    // call the below method to send deep link to Adjust's servers
    Adjust.appWillOpen(incomingURL)

    return true
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (BOOL)application:(UIApplication *)app
    openURL:(NSURL *)incomingURL
    options:(NSDictionary *)options {

    // add your code below to handle deep link
    // (for example, open deep link content)
    // incomingURL object contains the deep link


    // call the below method to send deep link to Adjust's servers
    [Adjust appWillOpenUrl:incomingURL];

    return YES;
}
```

</Tab> </Tabs> 

### [앱이 scene을 사용하는 경우](app-uses-scenes)

앱이 scene을 사용하는 경우, scene 델리게이트에서 메서드를 업데이트해야 합니다.

#### [유니버설 링크](universal-links-1)

1. scene 델리게이트에서 `scene(_:willConnectTo:options:)` 메서드를 업데이트합니다. 사용자가 유니버설 링크를 클릭하고 앱은 종료된 상태인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.
2. scene 델리게이트에서 `scene(_:continue:)` 메서드를 업데이트합니다. 사용자가 유니버설 링크를 클릭하고 앱이 백그라운드에서 실행 중인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.

위 메서드는 Adjust SDK에서 다음의 메서드를 호출합니다.

* `ADJLinkResolution.resolveLink`: 마케팅팀이 Adjust의 링크 해석\(link resolution\) 솔루션이 필요한 경우에만 이 메서드를 호출합니다. 딥링크가 `resolveUrlSuffixArray`의 요소와 일치하는 도메인을 사용하는 경우, 이 메서드는 딥링크를 해석하려고 시도하여 해석된 링크를 반환합니다. 딥링크가 이 배열의 요소와 일치하지 않는 경우, 이 메서드는 원래의 딥링크를 전달하므로 모든 딥링크를 이 메서드로 전달할 수 있습니다.
* `Adjust.appWillOpen` \- 이 메서드를 호출하여 기록을 위해 딥링크를 Adjust 서버로 전송합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.

<tabs> <tab title="Swift" sync="swift"> 

```swift
func scene(
    _ scene: UIScene,
    willConnectTo session: UISceneSession,
    options connectionOptions: UIScene.ConnectionOptions
    ) {

    guard let userActivity = connectionOptions.userActivities.first,
      userActivity.activityType == NSUserActivityTypeBrowsingWeb,
      let incomingURL = userActivity.webpageURL
    else { return }

    // call the below method to resolve deep link
    ADJLinkResolution.resolveLink(
      withUrl: incomingURL,
      resolveUrlSuffixArray: ["email.example.com", "short.example.com"],
      callback: { resolvedURL in
        // add your code below to handle deep link
        // (for example, open deep link content)
        // resolvedURL object contains the deep link


        // call the below method to send deep link to Adjust's servers
        Adjust.appWillOpen(resolvedURL)
      })
}

func scene(
    _ scene: UIScene,
    continue userActivity: NSUserActivity) {

    if userActivity.activityType == NSUserActivityTypeBrowsingWeb {
        let incomingURL = userActivity.webpageURL

        // call the below method to resolve deep link
        ADJLinkResolution.resolveLink(
        withUrl: incomingURL,
        resolveUrlSuffixArray: ["email.example.com", "short.example.com"],
        callback: { resolvedURL in
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            Adjust.appWillOpen(resolvedURL)
        })
    }
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session
    options:(UISceneConnectionOptions *)connectionOptions {

    NSUserActivity* userActivity =
    [[[connectionOptions userActivities] allObjects] firstObject];

    if ([[userActivity activityType]
        isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *incomingURL = [userActivity webpageURL];

        // call the below method to resolve deep link
        [ADJLinkResolution
        resolveLinkWithUrl:incomingURL
        resolveUrlSuffixArray:@[
        @"email.example.com", @"short.example.com"
        ]
        callback:^(NSURL* _Nullable resolvedURL) {
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            [Adjust appWillOpenUrl:resolvedURL];
        }];
    }
}

- (void)scene:(UIScene *)scene continueUserActivity:(NSUserActivity *)userActivity{
    if ([[userActivity activityType]
        isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *incomingURL = [userActivity webpageURL];

        // call the below method to resolve deep link
        [ADJLinkResolution
        resolveLinkWithUrl:incomingURL
        resolveUrlSuffixArray:@[
        @"email.example.com", @"short.example.com"
        ]
        callback:^(NSURL* _Nullable resolvedURL) {
            // add your code below to handle deep link
            // (for example, open deep link content)
            // resolvedURL object contains the deep link


            // call the below method to send deep link to Adjust's servers
            [Adjust appWillOpenUrl:resolvedURL];
        }];
    }
}
```

</Tab> </Tabs> 

#### [커스텀 URL 스킴](custom-url-scheme-2)

1. scene 델리게이트에서 `scene(_:willConnectTo:options:)` 메서드를 업데이트합니다. 사용자가 맞춤 URL 스킴 딥링크를 클릭하고 앱은 종료된 상태인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.
2. scene 델리게이트에서 `scene(_:openURLContexts:)` 메서드를 업데이트합니다. 사용자가 맞춤 URL 스킴 딥링크를 클릭하고 앱이 백그라운드에서 실행 중인 경우, iOS는 앱을 실행하고 딥링크를 이 메서드에 전달합니다.

위 메서드는 Adjust SDK에서 `Adjust.appWillOpen` 메서드를 호출합니다. 이 메서드는 딥링크를 Adjust 서버로 전송하여 이를 기록합니다. Adjust 딥링크와 비 Adjust 딥링크 모두 이 메서드를 통해 전달할 수 있습니다. Adjust 서버는 Adjust 파라미터가 없는 딥링크를 모두 무시합니다.
<tabs> <tab title="Swift" sync="swift"> 

```swift
func scene(
    _ scene: UIScene,
    openURLContexts URLContexts: Set<uiopenurlcontext id="sl-md0000000">
    ) {

    guard let incomingURL = URLContexts.first?.url else {
        return
    }

    // add your code below to handle deep link
    // (for example, open deep link content)
    // incomingURL object contains the deep link


    // call the below method to send deep link to Adjust's servers
    Adjust.appWillOpen(incomingURL)
}
```

</Tab> <tab title="Objective-C" sync="objc"> 

```objc
- (void)scene:(UIScene *)scene
    openURLContexts:(nonnull NSSet<uiopenurlcontext * id="sl-md0000000"> *)URLContexts {

    NSURL *incomingURL = [[URLContexts allObjects] firstObject].URL;

    if (incomingURL) {
        // add your code below to handle deep link
        // (for example, open deep link content)
        // incomingURL object contains the deep link


        // call the below method to send deep link to Adjust's servers
        [Adjust appWillOpenUrl:incomingURL];
    }
}
```

</Tab> </Tabs> </SdkVersion>

