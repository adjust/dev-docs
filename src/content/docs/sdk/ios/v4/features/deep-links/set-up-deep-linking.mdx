---
title: Set up deep linking
description: Set up deep linking in your app.
slug: en/sdk/ios/v4/features/deep-links/set-up-deep-linking
sidebar-position: 2
versions:
   - label: v5
     value: v5
     default: true
   - label: v4
     value: v4
redirects:
   v5: /en/sdk/ios/features/deep-links/set-up-deep-linking
---

Please follow the steps in the section that corresponds to the type of app you have:

-  [UIKit apps using AppDelegate lifecycle](#uikit-apps-using-appdelegate-lifecycle)
-  [UIKit apps using SceneDelegate lifecycle](#uikit-apps-using-scenedelegate-lifecycle)
-  [SwiftUI apps not using SceneDelegate lifecycle](#swiftui-apps-not-using-scenedelegate-lifecycle)
-  [SwiftUI apps using SceneDelegate lifecycle](#swiftui-apps-using-scenedelegate-lifecycle)

<Callout type="tip">

If you're using the Facebook SDK for deferred deep linking, disable or remove the [deferred deep linking code](https://developers.facebook.com/docs/ios/deep-linking#deferred-deep-linking) to avoid conflicts with Adjust SDK's deferred deep link handling.

</Callout>

## UIKit apps using AppDelegate lifecycle

Update your AppDelegate to implement direct and deferred deep linking.

<Tabs>
<Tab title="Swift" sync="swift">

<CodeBlock title="AppDelegate.swift">

```swift {38-39,54-101}
import Foundation
import UIKit
import Adjust

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate,
    AdjustDelegate
{

    var window: UIWindow?

    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions:
            [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        // Configure Adjust SDK
        // Replace {YourAppToken} with your Adjust app token
        let appToken = "{YourAppToken}"
        var adjustConfig: ADJConfig?

        #if DEBUG
            adjustConfig = ADJConfig(
                appToken: appToken,
                environment: ADJEnvironmentSandbox)
            adjustConfig?.logLevel = ADJLogLevelVerbose
        #else
            adjustConfig = ADJConfig(
                appToken: appToken,
                environment: ADJEnvironmentProduction,
                allowSuppressLogLevel: true)
            adjustConfig?.logLevel = ADJLogLevelSuppress
        #endif

        // Wait up to 120 seconds after app open for user to respond to ATT
        // before sending install session to Adjust's servers.
        // Ensure this interval is long enough for user to respond.
        adjustConfig?.attConsentWaitingInterval = 120

        // Create delegate for deferred deep linking
        adjustConfig?.delegate = self

        // Initialize Adjust SDK
        Adjust.appDidLaunch(adjustConfig)

        // Example: initialize window and root view controller
        window = UIWindow(frame: UIScreen.main.bounds)
        let rootViewController = ViewController()
        let navigationController = UINavigationController(
            rootViewController: rootViewController)
        window?.rootViewController = navigationController
        window?.makeKeyAndVisible()

        return true
    }

    // Receive universal link when app is installed
    // and user clicks link to open app
    // from one of these states:
    // not running, background, or foreground.
    func application(
        _ application: UIApplication,
        continue userActivity: NSUserActivity,
        restorationHandler:
            @escaping ([UIUserActivityRestoring]?) -> Void
    ) -> Bool {
        if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
            let incomingLink = userActivity.webpageURL
        {
            let navigationController =
                self.window?.rootViewController as? UINavigationController
            {
                // Handle incoming universal link
                DeeplinkHandler.handleDeeplink(
                    incomingLink,
                    navigationController: navigationController)
            }
        }
        return true
    }

    // Receive app scheme deep link when app is installed
    // and user clicks link to open app
    // from one of these states:
    // not running, background, or foreground.
    //
    // Also receive universal link or app scheme deep link
    // when app programmatically opens link
    // using UIApplication.shared.open.
    func application(
        _ application: UIApplication,
        open incomingLink: URL,
        options: [UIApplication.OpenURLOptionsKey: Any] = [:]
    ) -> Bool {
        let navigationController =
            self.window?.rootViewController as? UINavigationController
        {
            // Handle incoming deep link
            DeeplinkHandler.handleDeeplink(
                incomingLink,
                navigationController: navigationController)
        }
        return true
    }

    // Receive deferred deep link via AdjustDelegate method
    func adjustDeeplinkResponse(_ deeplink: URL?) -> Bool {
        if let incomingLink = deeplink {
            // Store incoming deferred deep link to invoke after
            // onboarding screens and login.
            UserDefaults.standard.set(
                incomingLink.absoluteString,
                forKey: "lastDeferredLink")
        }

        // Return true to try to open deep link immediately
        // upon receipt (for example: app has no ATT, onboarding screens, or login).
        // Otherwise, return false.
        return false
    }
}
```

</CodeBlock>

</Tab>
<Tab title="Objective-C" sync="objc">

<CodeBlock title="AppDelegate.m">

```objc {34-35, 53-103}
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#import <Adjust/Adjust.h>

@class DeeplinkHandler;
@class ViewController;

@interface AppDelegate : UIResponder <UIApplicationDelegate, AdjustDelegate>
@property(strong, nonatomic) UIWindow *window;
@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Configure Adjust SDK
    // Replace {YourAppToken} with your Adjust app token
    NSString *appToken = @"{YourAppToken}";
    ADJConfig *adjustConfig;

#ifdef DEBUG
    adjustConfig = [ADJConfig configWithAppToken:appToken
                                     environment:ADJEnvironmentSandbox];
    [adjustConfig setLogLevel:ADJLogLevelVerbose];
#else
    adjustConfig = [ADJConfig configWithAppToken:appToken
                                     environment:ADJEnvironmentProduction
                           allowSuppressLogLevel:YES];
    [adjustConfig setLogLevel:ADJLogLevelSuppress];
#endif

    // Wait up to 120 seconds after app open for user to respond to ATT
    // before sending install session to Adjust's servers.
    // Ensure this interval is long enough for user to respond.
    adjustConfig.attConsentWaitingInterval = 120;

    // Create delegate for deferred deep linking
    adjustConfig.delegate = self;

    // Initialize Adjust SDK
    [Adjust appDidLaunch:adjustConfig];

    // Example: initialize window and root view controller
    self.window =
        [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    UIViewController *rootViewController = [[UIViewController alloc] init];
    UINavigationController *navigationController =
        [[UINavigationController alloc]
            initWithRootViewController:rootViewController];
    self.window.rootViewController = navigationController;
    [self.window makeKeyAndVisible];

    return YES;
}

// Receive universal link when app is installed
// and user clicks link to open app
// from one of these states:
// not running, background, or foreground.
- (BOOL)application:(UIApplication *)application
    continueUserActivity:(NSUserActivity *)userActivity
      restorationHandler:
          (void (^)(NSArray<id<UIUserActivityRestoring>> *_Nullable))
              restorationHandler {
    if ([userActivity.activityType
            isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *incomingLink = userActivity.webpageURL;
        UINavigationController *navigationController =
            (UINavigationController *)self.window.rootViewController;
        if ([navigationController
                isKindOfClass:[UINavigationController class]]) {
            // Handle incoming universal link
            [DeeplinkHandler handleDeeplink:incomingLink
                       navigationController:navigationController];
        }
    }
    return YES;
}

// Receive app scheme deep link when app is installed
// and user clicks link to open app
// from one of these states:
// not running, background, or foreground.
//
// Also receive universal link or app scheme deep link
// when app programmatically opens link
// using [[UIApplication sharedApplication] openURL:...].
- (BOOL)application:(UIApplication *)app
            openURL:(NSURL *)incomingLink
            options:
                (NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options {
    UINavigationController *navigationController =
        (UINavigationController *)self.window.rootViewController;
    if ([navigationController isKindOfClass:[UINavigationController class]]) {
        // Handle incoming app scheme deep link
        [DeeplinkHandler handleDeeplink:incomingLink
                   navigationController:navigationController];
    }
    return YES;
}

// Receive deferred deep link via AdjustDelegate method
- (BOOL)adjustDeeplinkResponse:(NSURL *)deeplink {
    if (deeplink) {
        // Store incoming deferred deep link to invoke after
        // onboarding screens and login.
        [[NSUserDefaults standardUserDefaults]
            setObject:[deeplink absoluteString]
               forKey:@"lastDeferredLink"];
    }
    // Return YES to try to open deep link immediately
    // upon receipt (for example: app has no ATT, onboarding screens, or login).
    // Otherwise, return NO.
    return NO;
}

@end
```

</CodeBlock>

</Tab>
</Tabs>

For deferred deep linking, this is the sequence for most apps:

1. A user who doesn't have the app installed clicks an Adjust deep link, which redirects them to the app store.
2. The user installs and opens the app.
3. The app begins its onboarding process (for example: ATT prompt, onboarding screens, login prompt).
4. After the ATT prompt response or timeout, the Adjust SDK sends session and attribution requests to Adjust's servers.
5. Adjust's servers respond with attribution data, including the deep link the user clicked on ("deferred deep link").
6. The Adjust SDK triggers a deferred deep link callback in your app, which stores the deferred deep link (shown in the code example above).
7. Once onboarding completes, the app retrieves the stored deep link and navigates the user accordingly (shown in the code example below).

<Tabs>
<Tab title="Swift" sync="swift">

<CodeBlock title="ViewController.swift">

```swift
import Foundation
import UIKit
import Adjust

class ViewController: UIViewController {

    var hasCompletedOnboarding: Bool {
        get {
            UserDefaults.standard.bool(forKey: "HasCompletedOnboarding")
        }
        set {
            UserDefaults.standard.set(
                newValue, forKey: "HasCompletedOnboarding")
        }
    }

    override func viewDidAppear() {
        super.viewDidAppear()

        // Check if onboarding has been completed
        if !hasCompletedOnboarding {
            // Show ATT dialog
            Adjust.requestTrackingAuthorization(completionHandler: nil)

            // Show onboarding screens and login prompt

            // On completion, set hasCompletedOnboarding to true
            hasCompletedOnboarding = true
        }

        // Check if there's a stored deferred deep link
        if let deferredLinkString = UserDefaults.standard.string(
            forKey: "lastDeferredLink"),
            let deferredLink = URL(string: deferredLinkString)
        {
            // Remove the stored URL to avoid handling it again later
            UserDefaults.standard.removeObject(forKey: "lastDeferredLink")

            // Handle deferred deep link
            DeeplinkHandler.handleDeeplink(
                deferredLink, navigationController: self.navigationController)

        }
        else {
            // Show main content
        }
    }
}
```

</CodeBlock>

</Tab>
<Tab title="Objective-C" sync="objc">

<CodeBlock title="ViewController.m">

```objc
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#import <Adjust/Adjust.h>

@class DeeplinkHandler;

@interface ViewController : UIViewController

@end

@interface ViewController ()

@property(nonatomic, assign) BOOL hasCompletedOnboarding;

@end

@implementation ViewController

- (BOOL)hasCompletedOnboarding {
    return [[NSUserDefaults standardUserDefaults]
        boolForKey:@"HasCompletedOnboarding"];
}

- (void)setHasCompletedOnboarding:(BOOL)hasCompletedOnboarding {
    [[NSUserDefaults standardUserDefaults] setBool:hasCompletedOnboarding
                                            forKey:@"HasCompletedOnboarding"];
}

- (void)viewDidAppear {
    [super viewDidAppear];

    // Check if onboarding has been completed
    if (!self.hasCompletedOnboarding) {
        // Show ATT prompt
        [Adjust requestTrackingAuthorizationWithCompletionHandler:nil];

        // Show onboarding screens and login prompt
        // On completion, set hasCompletedOnboarding to true
        self.hasCompletedOnboarding = YES;
    }

    // Check if there's a stored deferred deep link
    NSString *deferredLinkString = [[NSUserDefaults standardUserDefaults]
        stringForKey:@"lastDeferredLink"];
    NSURL *deferredLink = [NSURL URLWithString:deferredLinkString];

    if (deferredLink) {
        // Remove the stored URL to avoid handling it again later
        [[NSUserDefaults standardUserDefaults]
            removeObjectForKey:@"lastDeferredLink"];

        // Handle deferred deep link
        [DeeplinkHandler handleDeeplink:deferredLink
                   navigationController:self.navigationController];
    } else {
        // Show main content
    }
}

@end
```

</CodeBlock>

</Tab>
</Tabs>

The preceding code examples use the example DeeplinkHandler class below. This code example handles all types of links:

-  Adjust branded links (full go.link links)
-  Adjust short branded links (short go.link links)
-  Adjust universal links (adj.st links)
-  Non-Adjust universal links (example.com links)
-  App scheme deep links (example:// links)

The class performs the following tasks:

1. The class uses Adjust's `processDeeplink` method, which sends the deep link to Adjust's servers to accomplish two things:

-  Record the deep link for attribution.
-  Resolve [Adjust short branded link](https://www.help.adjust.com/en/article/short-branded-links) and respond with full URL, if applicable.

2. After processing, the class parses the link and navigates to the appropriate screen. This part of the code is specific to each app. Your app has to implement its own logic for handling deep links and opening the corresponding content. Your deep link handling has to meet the following key requirements:

-  Your app should treat Adjust branded links the same as other universal links, such as your own. Adjust recommends implementing domain-agnostic deep link handling logic to meet this requirement. For example, the following links should navigate to the same screen in your app:
   -  Adjust branded link: `https://example.go.link/summer-clothes?promo=beach`
   -  Your universal link: `https://www.example.com/summer-clothes?promo=beach`
-  In cases where iOS doesn't support universal links, Adjust automatically converts them to app scheme deep links. Additionally, Adjust's servers convert all deferred deep links to app scheme deep link format. Therefore it's crucial for the app to handle universal links and app scheme deep links equivalently. For example, the following links should navigate to the same screen in your app:
   -  Adjust branded link: `https://example.go.link/summer-clothes?promo=beach`
   -  App scheme deep link: `example://summer-clothes?promo=beach`

<Tabs>
<Tab title="Swift" sync="swift">

<CodeBlock title="DeeplinkHandler.swift">

```swift
import Foundation
import UIKit
import Adjust

class DeeplinkHandler {

    static func handleDeeplink(
        _ incomingLink: URL,
        navigationController: UINavigationController?
    ) {
        // Send incoming deep link to Adjust for attribution,
        // and resolve short link, if applicable.
        Adjust.processDeeplink(incomingLink) { processedLinkString in
            guard let processedLink = URL(string: processedLinkString) else {
                print("Invalid processed link")
                return
            }

            // Extract path, query items, and fragment from the
            // resolved link.
            let components = URLComponents(
                url: processedLink,
                resolvingAgainstBaseURL: true)
            let path = components?.path ?? ""
            let queryItems = components?.queryItems
            let fragment = components?.fragment

            // Implement the navigation or other app-specific
            // logic based on the deep link components.
            // Example: Navigate to a specific view controller within the
            // navigationController.
            DispatchQueue.main.async {
                // Example of navigating based on the path or
                // other components. This is a placeholder.
                // Replace with your actual navigation logic.
                // Handle paths, query items, and fragments
                // as needed.
                if path == "/somePath" {
                    let viewController = SomeViewController()
                    navigationController?.pushViewController(
                        viewController, animated: true)
                }
            }
        }
    }
}
```

</CodeBlock>

</Tab>
<Tab title="Objective-C" sync="objc">

<CodeBlock title="DeeplinkHandler.m">

```objc
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#import <Adjust/Adjust.h>

@interface DeeplinkHandler : NSObject

+ (void)handleDeeplink:(NSURL *)incomingLink
    navigationController:(UINavigationController *)navigationController;

@end

@implementation DeeplinkHandler

+ (void)handleDeeplink:(NSURL *)incomingLink
    navigationController:(UINavigationController *)navigationController {
    // Send incoming deep link to Adjust for attribution,
    // and resolve short link, if applicable.
    [Adjust
        processDeeplink:incomingLink
             completion:^(NSString *_Nullable processedLinkString) {
               NSURL *processedLink = [NSURL URLWithString:processedLinkString];
               if (!processedLink) {
                   NSLog(@"Invalid processed link");
                   return;
               }

               // Extract path, query items, and fragment from the
               // resolved link.
               NSURLComponents *components =
                   [NSURLComponents componentsWithURL:processedLink
                              resolvingAgainstBaseURL:YES];
               NSString *path = components.path ?: @"";
               NSArray<NSURLQueryItem *> *queryItems = components.queryItems;
               NSString *fragment = components.fragment;

               // Implement the navigation or other app-specific
               // logic based on the deep link components.
               // Example: Navigate to a specific view controller within the
               // navigationController.
               dispatch_async(dispatch_get_main_queue(), ^{
                 // Example of navigating based on the path or
                 // other components. This is a placeholder.
                 // Replace with your actual navigation logic.
                 // Handle paths, query items, and fragments
                 // as needed.
                 if ([path isEqualToString:@"/somePath"]) {
                     UIViewController *viewController =
                         [[UIViewController alloc] init];
                     [navigationController pushViewController:viewController
                                                     animated:YES];
                 }
               });
             }];
}

@end
```

</CodeBlock>

</Tab>
</Tabs>

## UIKit apps using SceneDelegate lifecycle

Follow the steps in the [UIKit apps using AppDelegate lifecycle section](#uikit-apps-using-appdelegate-lifecycle), except instead of implementing the `application(_:continue:restorationHandler:)` and `application(_:open:options:)` methods in your AppDelegate for direct deep linking, implement the following methods in your SceneDelegate.

<Tabs>
<Tab title="Swift" sync="swift">

<CodeBlock title="SceneDelegate.swift">

```swift
import Foundation
import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

  var window: UIWindow?

  // Receive universal link or app scheme deep link
  // when app is installed and user clicks link to
  // open app from "not running" state or to create new scene.
  func scene(
    _ scene: UIScene,
    willConnectTo session: UISceneSession,
    options connectionOptions: UIScene.ConnectionOptions
  ) {
    // Example: initialize and make the window visible
    guard let windowScene = (scene as? UIWindowScene) else { return }
    window = UIWindow(windowScene: windowScene)
    let rootViewController = ViewController()
    let navigationController = UINavigationController(
      rootViewController: rootViewController)
    window?.rootViewController = navigationController
    window?.makeKeyAndVisible()

    if let urlContext = connectionOptions.urlContexts.first {
      let incomingLink = urlContext.url

      // Handle incoming deep link
      DeeplinkHandler.handleDeeplink(
        incomingLink,
        navigationController: navigationController)
    }
  }

  // Receive universal link when app is installed
  // and user clicks link to open app to existing scene
  // from background or foreground state.
  func scene(_ scene: UIScene, continue userActivity: NSUserActivity) {
    if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
      let incomingLink = userActivity.webpageURL
    {
      // Handle incoming universal link
      DeeplinkHandler.handleDeeplink(
        incomingLink,
        navigationController: navigationController)
    }
  }

  // Receive app scheme deep link when app is installed
  // and user clicks link to open app to existing scene
  // from background or foreground state.
  //
  // Also receive universal link or app scheme deep link
  // when app programmatically opens link
  // using UIApplication.shared.open.
  func scene(
    _ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>
  ) {
    if let urlContext = URLContexts.first {
      let incomingLink = urlContext.url

      // Handle incoming deep link
      DeeplinkHandler.handleDeeplink(
        incomingLink,
        navigationController: navigationController)
    }
  }
}
```

</CodeBlock>

</Tab>
<Tab title="Objective-C" sync="objc">

<CodeBlock title="SceneDelegate.m">

```objc
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

@class DeeplinkHandler;
@class ViewController;

@interface SceneDelegate : UIResponder <UIWindowSceneDelegate>

@property(strong, nonatomic) UIWindow *window;

@end

@implementation SceneDelegate

// Receive universal link or app scheme deep link
// when app is installed and user clicks link to
// open app from "not running" state or to create new scene.
- (void)scene:(UIScene *)scene
    willConnectToSession:(UISceneSession *)session
                 options:(UISceneConnectionOptions *)connectionOptions {
  // Example: initialize and make the window visible
  UIWindowScene *windowScene = (UIWindowScene *)scene;
  self.window = [[UIWindow alloc] initWithWindowScene:windowScene];
  ViewController *rootViewController = [[ViewController alloc] init];
  UINavigationController *navigationController = [[UINavigationController alloc]
      initWithRootViewController:rootViewController];
  self.window.rootViewController = navigationController;
  [self.window makeKeyAndVisible];

  if (connectionOptions.URLContexts.count > 0) {
    UIOpenURLContext *urlContext =
        connectionOptions.URLContexts.allObjects.firstObject;
    NSURL *incomingLink = urlContext.URL;

    // Handle incoming deep link
    [DeeplinkHandler handleDeeplink:incomingLink
               navigationController:navigationController];
  }
}

// Receive universal link when app is installed
// and user clicks link to open app to existing scene
// from background or foreground state.
- (void)scene:(UIScene *)scene
    continueUserActivity:(NSUserActivity *)userActivity {
  if ([userActivity.activityType
          isEqualToString:NSUserActivityTypeBrowsingWeb]) {
    NSURL *incomingLink = userActivity.webpageURL;

    // Handle incoming universal link
    [DeeplinkHandler handleDeeplink:incomingLink
               navigationController:self.window.rootViewController];
  }
}

// Receive app scheme deep link when app is installed
// and user clicks link to open app to existing scene
// from background or foreground state.
//
// Also receive universal link or app scheme deep link
// when app programmatically opens link
// using [[UIApplication sharedApplication] openURL:...].
- (void)scene:(UIScene *)scene
    openURLContexts:(NSSet<UIOpenURLContext *> *)URLContexts {
  UIOpenURLContext *urlContext = URLContexts.allObjects.firstObject;
  if (urlContext) {
    NSURL *incomingLink = urlContext.URL;

    // Handle incoming deep link
    [DeeplinkHandler handleDeeplink:incomingLink
               navigationController:self.window.rootViewController];
  }
}

@end
```

</CodeBlock>

</Tab>
</Tabs>

## SwiftUI apps not using SceneDelegate lifecycle

Create an `AppDelegate.swift` file in your project's main directory and reference it in your main application file (for example: `App.swift` as shown below). This is required to handle app lifecycle events and Adjust SDK integration.

<Tabs>
<Tab title="Swift" sync="swift">

```swift
// App.swift

import SwiftUI

@main
struct MyApp: App {
  @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

  var body: some Scene {
    WindowGroup {
      ContentView()
        .environmentObject(DeeplinkManager.shared)
    }
  }
}
```

</Tab>
</Tabs>

Update your AppDelegate to implement direct deep linking and deferred deep linking.

<Tabs>
<Tab title="Swift" sync="swift">

```swift
// AppDelegate.swift

import Adjust
import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate,
  UNUserNotificationCenterDelegate, AdjustDelegate {

  let deeplinkManager = DeeplinkManager.shared

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication
      .LaunchOptionsKey: Any]?) -> Bool {
    // Set delegate for push notifications
    UNUserNotificationCenter.current().delegate = self

    // Configure Adjust SDK
    // Replace {YourAppToken} with your Adjust app token
    let appToken = "{YourAppToken}"
    let adjustConfig: ADJConfig?

    #if DEBUG
      adjustConfig = ADJConfig(
        appToken: appToken,
        environment: ADJEnvironmentSandbox)
      adjustConfig?.logLevel = ADJLogLevelVerbose
    #else
      adjustConfig = ADJConfig(
        appToken: appToken,
        environment: ADJEnvironmentProduction,
        allowSuppressLogLevel: true)
      adjustConfig?.logLevel = ADJLogLevelSuppress
    #endif

    // Wait up to 30 seconds after app open for user to respond to ATT
    // before sending install session to Adjust backend.
    adjustConfig.attConsentWaitingInterval = 30

    // Create delegate for deferred deep linking
    adjustConfig.delegate = self

    // Initialize Adjust SDK
    Adjust.appDidLaunch(adjustConfig)

    // Initialize and make window visible
    let contentView = ContentView().environmentObject(deeplinkManager)
    if let windowScene = UIApplication.shared.connectedScenes.first
      as? UIWindowScene {
      let window = UIWindow(windowScene: windowScene)
      window.rootViewController = UIHostingController(
        rootView: contentView)
      self.window = window
      window.makeKeyAndVisible()
    }

    return true
  }

  // Receive push notification while app is in foreground
  func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    willPresent notification: UNNotification) async ->
    UNNotificationPresentationOptions {

    // Add your push notification handling here

    // Change to your preferred presentation option
    return [.alert, .sound]
  }

  // Receive direct universal link or app scheme deep link
  // from push notification while app isn't running,
  // in background, or in foreground and user interacts
  // with push notification.
  // Replace "{deepLink}" with your custom key name.
  func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    didReceive response: UNNotificationResponse) async {
    let userInfo = response.notification.request.content
      .userInfo

    // Add your push notification handling here

    if let deepLinkURLString = userInfo["{deepLink}"]
      as? String,
      let incomingLink = URL(
        string: deepLinkURLString) {
      // Update DeeplinkManager with incoming deep link
      self.deeplinkManager.updateDeeplinkState(with: incomingLink)
      }
    }
  }

  // Receive direct universal link while app isn't running,
  // or in background.
  func application(
    _ application: UIApplication,
    continue userActivity: NSUserActivity,
    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
    if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
      let incomingLink = userActivity.webpageURL {
      // Update DeeplinkManager with incoming universal link
      self.deeplinkManager.updateDeeplinkState(with: incomingLink)
      }
    }
    return true
  }

  // Receive direct app scheme deep link while app isn't running,
  // or in background.
  func application(
    _ application: UIApplication,
    open incomingLink: URL,
    options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {

    // Update DeeplinkManager with incoming app scheme deep link
    self.deeplinkManager.updateDeeplinkState(with: incomingLink)

    return true
  }

  // Receive deferred deep link via AdjustDelegate method
  func adjustDeeplinkResponse(_ deeplink: URL?) -> Bool {
    if let incomingLink = deeplink {
      // Store incoming deferred deep link to invoke after
      // onboarding screens and login.
      UserDefaults.standard.set(
        incomingLink.absoluteString,
        forKey: "DeferredDeeplinkURL")
    }

    // Return true to try to open deep link immediately upon receipt.
    // Otherwise, return false.
    return false
  }
}
```

</Tab>
</Tabs>

Update your SceneDelegate to implement direct linking.

<Tabs>
<Tab title="Swift" sync="swift">

```swift
// SceneDelegate.swift

import SwiftUI
import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate, AdjustDelegate {

  var window: UIWindow?
  let deeplinkManager = DeeplinkManager.shared

  // Receive direct universal link or app scheme deep link
  // while app isn't running, or when new scene is created
  func scene(_ scene: UIScene,
         willConnectTo session: UISceneSession,
         options connectionOptions: UIScene.ConnectionOptions) {
    // Initialize and make window visible
    let contentView = ContentView().environmentObject(deeplinkManager)
    if let windowScene = scene as? UIWindowScene {
      let window = UIWindow(windowScene: windowScene)
      window.rootViewController = UIHostingController(rootView: contentView)
      self.window = window
      window.makeKeyAndVisible()
    }

    if let urlContext = connectionOptions.urlContexts.first {
      let incomingLink = urlContext.url

      // Update DeeplinkManager with incoming deep link
      deeplinkManager.updateDeeplinkState(with: incomingLink)
    }
  }

  // Receive direct universal links while app is in background
  func scene(_ scene: UIScene, continue userActivity: NSUserActivity) {
    if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
       let incomingLink = userActivity.webpageURL {
        // Update DeeplinkManager with incoming universal link
        deeplinkManager.updateDeeplinkState(with: incomingLink)
    }
  }

  // Receive direct app scheme deep link in existing scene
  // while app is in background.
  func scene(_ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>) {
    if let urlContext = URLContexts.first {
      let incomingLink = urlContext.url

      // Update DeeplinkManager with incoming app scheme deep link
      deeplinkManager.updateDeeplinkState(with: incomingLink)
    }
  }
}
```

</Tab>
</Tabs>

When your AppDelegate receives a direct deep link, your SwiftUI views have to observe the updated deep link state. To facilitate this, you can create a centralized class to manage deep link states in your app, such as the below `DeeplinkManager.swift` implementation that the above example invokes.

<Tabs>
<Tab title="Swift" sync="swift">

```swift
// DeeplinkManager.swift

import SwiftUI

class DeeplinkManager: ObservableObject {
  static let shared = DeeplinkManager()
  @Published var deeplink: URL?

  // Update current deep link state
  func updateDeeplinkState(with url: URL) {
    DispatchQueue.main.async {
      self.deeplink = url
    }
  }

  // Remove current deep link
  func RemoveDeeplink() {
    DispatchQueue.main.async {
      self.deeplink = nil
    }
  }
}
```

</Tab>
</Tabs>

Your SwiftUI views have to react to changes in the direct deep link state and open the deep link content. Below is an example `ContentView.swift` implementation that does this.

On first app open, if your app displays onboarding screens and/or prompts the user to log in, afterward your app has to retrieve and handle the stored deferred deep link (for example: in `ContentView.swift` as shown below). If your app doesn't display onboarding screens or prompt the user to log in, and you want the Adjust SDK to open the deferred deep link immediately on first app open, then you can skip the deferred deep linking logic shown below.

The below code also shows the ATT prompt, which may or may not be applicable for your app's onboarding process. After the user responds to the ATT prompt (or the ATT waiting interval expires, whichever comes first), the SDK sends the /session and /attribution requests to Adjust's servers. Adjust's servers then respond with the deferred deep link in the /attribution response.

<Tabs>
<Tab title="Swift" sync="swift">

```swift
// ContentView.swift

import AppTrackingTransparency
import SwiftUI

struct ContentView: View {
  @EnvironmentObject var deeplinkManager: DeeplinkManager
  @State private var hasCompletedOnboarding: Bool = false

  var body: some View {
    NavigationView {
      // Check if onboarding has been completed
      if !hasCompletedOnboarding {
        // Show ATT prompt
        ATTrackingManager.requestTrackingAuthorization { _ in }

        // Show onboarding screens and user login here

        // On completion, set hasCompletedOnboarding to true
        hasCompletedOnboarding = true
      }

      // Check if there's a stored deferred deep link
      if let deferredLinkString = UserDefaults.standard.string(
        forKey: "DeferredDeeplinkURL"),
        let deferredLink = URL(string: deferredLinkString) {

        // Handle deferred deep link
        DeeplinkHandler.shared.handleDeeplink(deferredLink)

        // Remove stored URL to avoid handling it again later
        UserDefaults.standard.removeObject(
          forKey: "DeferredDeeplinkURL")
      } else {
        // Show main content
      }
    }

    // Receive direct universal link or app scheme deep link
    // from deeplinkManager.
    .onReceive(deeplinkManager.$deeplink) { deeplink in
      if let incomingLink = deeplink {
        // Send incoming deep link to Adjust for attribution,
        // and resolve short link, if applicable.
        Adjust.processDeeplink(incomingLink) { processedLinkString in
          guard
            let processedLink = URL(string: processedLinkString ?? "")
          else {
            print("Invalid processed link")
            return
          }

          // Handle resolved deep link
          DeeplinkHandler.shared.handleDeeplink(processedLink)
        }

        // Remove deep link to avoid handling it again later
        deeplinkManager.RemoveDeeplink()
      }
    }

    // Receive direct universal link or app scheme deep link
    // while app is in foreground.
    .onOpenURL { incomingLink in
      Adjust.processDeeplink(incomingLink) { processedLinkString in
        guard let processedLink = URL(string: processedLinkString ?? "")
        else {
          print("Invalid processed link")
          return
        }

        // Handle resolved deep link
        DeeplinkHandler.shared.handleDeeplink(processedLink)
      }
    }
  }
}
```

</Tab>
</Tabs>

## SwiftUI apps using SceneDelegate lifecycle

"App"

Update your AppDelegate to implement deferred deep linking.

<Tabs>
<Tab title="Swift" sync="swift">

```swift
// AppDelegate.swift

import Adjust
import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate,
  UNUserNotificationCenterDelegate, AdjustDelegate {

  let deeplinkManager = DeeplinkManager.shared

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions:
      [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    // Set delegate for push notifications
    UNUserNotificationCenter.current().delegate = self

    // Configure Adjust SDK
    // Replace {YourAppToken} with your Adjust app token
    let appToken = "{YourAppToken}"
    let adjustConfig: ADJConfig?

    #if DEBUG
      adjustConfig = ADJConfig(
        appToken: appToken,
        environment: ADJEnvironmentSandbox)
      adjustConfig?.logLevel = ADJLogLevelVerbose
    #else
      adjustConfig = ADJConfig(
        appToken: appToken,
        environment: ADJEnvironmentProduction,
        allowSuppressLogLevel: true)
      adjustConfig?.logLevel = ADJLogLevelSuppress
    #endif

    // Wait up to 30 seconds after app open for user to respond to ATT
    // before sending install session to Adjust backend.
    adjustConfig.attConsentWaitingInterval = 30

    // Create delegate for deferred deep linking
    adjustConfig.delegate = self

    // Initialize Adjust SDK
    Adjust.appDidLaunch(adjustConfig)

    return true
  }

  // Receive push notification while app is in foreground
  func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    willPresent notification: UNNotification) async ->
    UNNotificationPresentationOptions {

    // Add your push notification handling here

    // Change to your preferred presentation option
    return [.alert, .sound]
  }

  // Receive direct universal link or app scheme deep link
  // from push notification while app isn't running,
  // in background, or in foreground and user interacts
  // with push notification.
  // Replace "{deepLink}" with your custom key name.
  func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    didReceive response: UNNotificationResponse) async {
    let userInfo = response.notification.request.content
      .userInfo

    // Add your push notification handling here

    if let deepLinkURLString = userInfo["{deepLink}"]
      as? String,
      let incomingLink = URL(
        string: deepLinkURLString) {
      // Update DeeplinkManager with incoming deep link
      self.deeplinkManager.updateDeeplinkState(
        with: incomingLink)
    }
  }

  // Receive deferred deep link via AdjustDelegate method
  func adjustDeeplinkResponse(_ deeplink: URL?) -> Bool {
    if let incomingLink = deeplink {
      // Store incoming deferred deep link to invoke after
      // onboarding screens and login.
      UserDefaults.standard.set(
        incomingLink.absoluteString,
        forKey: "DeferredDeeplinkURL")
    }

    // Return true to try to open deep link immediately upon receipt.
    // Otherwise, return false.
    return false
  }
}
```

</Tab>
</Tabs>

Update your SceneDelegate to implement direct linking.

<Tabs>
<Tab title="Swift" sync="swift">

```swift
// SceneDelegate.swift

import SwiftUI
import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate, AdjustDelegate {

  var window: UIWindow?
  let deeplinkManager = DeeplinkManager.shared

  // Receive direct universal link or app scheme deep link
  // while app isn't running, or when new scene is created
  func scene(_ scene: UIScene,
         willConnectTo session: UISceneSession,
         options connectionOptions: UIScene.ConnectionOptions) {
    // Initialize and make window visible
    let contentView = ContentView().environmentObject(deeplinkManager)
    if let windowScene = scene as? UIWindowScene {
      let window = UIWindow(windowScene: windowScene)
      window.rootViewController = UIHostingController(rootView: contentView)
      self.window = window
      window.makeKeyAndVisible()
    }

    if let urlContext = connectionOptions.urlContexts.first {
      let incomingLink = urlContext.url

      // Update DeeplinkManager with incoming deep link
      deeplinkManager.updateDeeplinkState(with: incomingLink)
    }
  }

  // Receive direct universal links while app is in background
  func scene(_ scene: UIScene, continue userActivity: NSUserActivity) {
    if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
       let incomingLink = userActivity.webpageURL {
        // Update DeeplinkManager with incoming universal link
        deeplinkManager.updateDeeplinkState(with: incomingLink)
    }
  }

  // Receive direct app scheme deep link in existing scene
  // while app is in background.
  func scene(_ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>) {
    if let urlContext = URLContexts.first {
      let incomingLink = urlContext.url

      // Update DeeplinkManager with incoming app scheme deep link
      deeplinkManager.updateDeeplinkState(with: incomingLink)
    }
  }
}
```

</Tab>
</Tabs>

"Deeplink Manager"

"Content View"
